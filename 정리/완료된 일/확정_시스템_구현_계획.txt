# 확정 시스템 구현 계획

## 📋 개요

자동배정된 시간을 확정하여 각 조원의 개인일정으로 자동 변환하는 시스템을 구현합니다.

---

## 🎯 요구사항 정리

### 사용자 시나리오
1. **일정 맞추기 탭**에서 방에 들어간다
2. **자동배정 버튼**을 누르면 시간이 배정된다
3. **확정 버튼**을 누르면:
   - 배정된 시간이 각 조원의 **개인일정**으로 변환된다
   - 예: A 조원이 월요일 9-12시 **선호시간**을 가지고 있었는데, 자동배정으로 월요일 9-11시를 받았다면
   - 확정 시 → A의 프로필 탭에서 월요일 9-11시가 **개인일정**으로 자동 추가된다
4. **효과**:
   - 해당 시간은 이제 **개인일정**이 되어 다른 자동배정에서 제외된다
   - **조원 목록**에서 해당 조원의 시간표를 봐도 개인일정으로 표시된다
   - **초기화 버튼**을 누르지 않는 한 영구적으로 유지된다

---

## 🗂️ 현재 시스템 분석

### 1. 데이터 구조

#### User 모델 (`server/models/user.js`)
```javascript
// 선호시간 (주간 반복)
defaultSchedule: [{
  dayOfWeek: Number,      // 0: 일요일 ~ 6: 토요일
  startTime: String,      // "09:00"
  endTime: String,        // "12:00"
  priority: Number,       // 1-3
  specificDate: String    // "2025-05-15" (특정 날짜)
}]

// 예외 일정 (챗봇으로 추가된 선호시간)
scheduleExceptions: [{
  title: String,
  startTime: Date,
  endTime: Date,
  priority: Number,
  specificDate: String,   // "2025-05-15"
  isHoliday: Boolean,
  isAllDay: Boolean
}]

// 개인시간 (수면, 식사, 출퇴근 등)
personalTimes: [{
  id: Number,
  title: String,
  type: String,           // 'sleep', 'meal', 'commute', 'study', 'break', 'custom', 'event'
  startTime: String,      // "09:00"
  endTime: String,        // "11:00"
  days: [Number],         // [1, 2, 3] = 월, 화, 수
  isRecurring: Boolean,   // true: 주간 반복, false: 일회성
  specificDate: String,   // "2025-05-15" (일회성 개인시간용)
  color: String
}]
```

#### Room 모델 (`server/models/room.js`)
```javascript
timeSlots: [{
  day: String,            // "monday", "tuesday", ...
  date: Date,             // 실제 날짜
  startTime: String,      // "09:00"
  endTime: String,        // "11:00"
  subject: String,        // "자동 배정"
  user: ObjectId,         // 배정받은 조원
  assignedBy: ObjectId,   // 방장 ID
  assignedAt: Date,
  status: String,         // "confirmed", "pending", "conflict"
  priority: Number
}]

members: [{
  user: ObjectId,
  joinedAt: Date,
  color: String,
  carryOver: Number,      // 이월시간
  totalProgressTime: Number, // 완료시간
  priority: Number
}]
```

### 2. 주요 컴포넌트

#### `CoordinationTab` (`client/src/components/tabs/CoordinationTab/index.js`)
- 일정 맞추기 탭의 메인 컴포넌트
- `AutoSchedulerPanel` 렌더링
- `handleRunAutoScheduleCallback` - 자동배정 실행

#### `AutoSchedulerPanel` (`client/src/components/scheduler/AutoSchedulerPanel.js`)
- 자동배정 버튼 및 옵션
- 현재 버튼들:
  - 자동 배정 실행
  - 이월초기화
  - 완료초기화
  - 내역 삭제
  - 전체 비우기

#### `ProfileTab` (`client/src/components/tabs/ProfileTab/index.js`)
- 사용자 프로필 관리
- `defaultSchedule`, `personalTimes`, `scheduleExceptions` 관리
- `PersonalTimeManager` 컴포넌트 사용

#### `MemberList` (`client/src/components/coordination/MemberList.js`)
- 조원 목록 표시
- 조원 클릭 시 통계/시간표 모달 표시

### 3. API 엔드포인트

#### 자동배정 (`server/controllers/coordinationSchedulingController.js`)
- `POST /api/coordination/rooms/:roomId/auto-schedule`
- 자동배정 알고리즘 실행
- `timeSlots`에 배정 결과 저장

---

## 🛠️ 구현 계획

### Phase 1: UI 추가 (클라이언트)

#### 1.1 확정 버튼 추가
**파일**: `client/src/components/scheduler/AutoSchedulerPanel.js`

**위치**: "자동 배정 실행" 버튼 아래

**디자인**:
```jsx
<button
  onClick={onConfirmSchedule}
  disabled={!hasAutoAssignedSlots}
  className="w-full bg-gradient-to-r from-green-500 to-green-600 text-white py-2 px-3 rounded-lg font-medium hover:from-green-600 hover:to-green-700 disabled:from-gray-300 disabled:to-gray-400 transition-all duration-200 shadow-md flex items-center justify-center text-sm"
>
  <CheckCircle size={16} className="mr-2" />
  배정 시간 확정
</button>
```

**Props 추가**:
```javascript
const AutoSchedulerPanel = ({
  // ... 기존 props
  onConfirmSchedule,  // 새로 추가
}) => {
  // ...
}
```

#### 1.2 확정 상태 표시
**파일**: `client/src/components/tabs/CoordinationTab/components/TimetableControls.js`

**추가 요소**:
- 확정된 슬롯 개수 표시
- 확정 상태 뱃지

---

### Phase 2: 서버 API 구현

#### 2.1 확정 API 엔드포인트
**파일**: `server/controllers/coordinationSchedulingController.js`

**새 함수 추가**:
```javascript
/**
 * @desc    자동배정된 시간을 각 조원의 개인일정으로 확정
 * @route   POST /api/coordination/rooms/:roomId/confirm-schedule
 * @access  Private (Room Owner only)
 */
exports.confirmSchedule = async (req, res) => {
  try {
    const { roomId } = req.params;
    
    // 1. 방 조회 (populate members)
    const room = await Room.findById(roomId)
      .populate('owner', 'firstName lastName email')
      .populate('members.user', '_id firstName lastName email personalTimes');
    
    if (!room) {
      return res.status(404).json({ msg: '방을 찾을 수 없습니다.' });
    }
    
    // 2. 방장 권한 확인
    if (!room.isOwner(req.user.id)) {
      return res.status(403).json({ msg: '방장만 이 기능을 사용할 수 있습니다.' });
    }
    
    // 3. 자동배정된 슬롯 필터링 (assignedBy가 있고 status가 'confirmed'인 것)
    const autoAssignedSlots = room.timeSlots.filter(slot => 
      slot.assignedBy && slot.status === 'confirmed'
    );
    
    if (autoAssignedSlots.length === 0) {
      return res.status(400).json({ msg: '확정할 자동배정 시간이 없습니다.' });
    }
    
    // 4. 조원별로 그룹화
    const slotsByUser = {};
    autoAssignedSlots.forEach(slot => {
      const userId = slot.user.toString();
      if (!slotsByUser[userId]) {
        slotsByUser[userId] = [];
      }
      slotsByUser[userId].push(slot);
    });
    
    // 5. 각 조원의 personalTimes에 추가
    const updatePromises = [];
    
    for (const [userId, slots] of Object.entries(slotsByUser)) {
      const user = await User.findById(userId);
      if (!user) continue;
      
      // personalTimes 배열이 없으면 초기화
      if (!user.personalTimes) {
        user.personalTimes = [];
      }
      
      // 다음 ID 계산
      const maxId = user.personalTimes.reduce((max, pt) => Math.max(max, pt.id || 0), 0);
      let nextId = maxId + 1;
      
      // 각 슬롯을 personalTimes로 변환
      slots.forEach(slot => {
        const dayOfWeek = getDayOfWeekNumber(slot.day); // "monday" -> 1
        
        // 중복 체크 (같은 날짜, 같은 시간)
        const isDuplicate = user.personalTimes.some(pt => 
          pt.specificDate === slot.date.toISOString().split('T')[0] &&
          pt.startTime === slot.startTime &&
          pt.endTime === slot.endTime
        );
        
        if (!isDuplicate) {
          user.personalTimes.push({
            id: nextId++,
            title: `${room.name} 확정 시간`,
            type: 'event',
            startTime: slot.startTime,
            endTime: slot.endTime,
            days: [dayOfWeek],
            isRecurring: false,
            specificDate: slot.date.toISOString().split('T')[0],
            color: '#10B981' // 초록색
          });
        }
      });
      
      updatePromises.push(user.save());
    }
    
    // 6. 방장의 personalTimes에도 추가 (각 조원별로 개별 수업 시간)
    const owner = await User.findById(room.owner._id || room.owner);
    if (owner) {
      if (!owner.personalTimes) {
        owner.personalTimes = [];
      }
      
      const maxId = owner.personalTimes.reduce((max, pt) => Math.max(max, pt.id || 0), 0);
      let nextId = maxId + 1;
      
      // 각 슬롯을 방장의 개인일정으로 추가 (조원별 개별 추가)
      for (const slot of autoAssignedSlots) {
        const dayOfWeek = getDayOfWeekNumber(slot.day);
        const dateStr = slot.date.toISOString().split('T')[0];
        
        // 해당 조원 정보 찾기
        const memberUser = room.members.find(m => 
          m.user._id?.toString() === slot.user.toString() || 
          m.user.toString() === slot.user.toString()
        );
        
        if (!memberUser) continue;
        
        const memberName = `${memberUser.user.firstName || ''} ${memberUser.user.lastName || ''}`.trim() || '조원';
        
        // 중복 체크 (같은 날짜, 같은 시간, 같은 조원)
        const isDuplicate = owner.personalTimes.some(pt => 
          pt.specificDate === dateStr &&
          pt.startTime === slot.startTime &&
          pt.endTime === slot.endTime &&
          pt.title.includes(memberName)
        );
        
        if (!isDuplicate) {
          owner.personalTimes.push({
            id: nextId++,
            title: `${room.name} 수업 (${memberName})`,
            type: 'event',
            startTime: slot.startTime,
            endTime: slot.endTime,
            days: [dayOfWeek],
            isRecurring: false,
            specificDate: dateStr,
            color: '#3B82F6' // 파란색 (방장 수업 시간)
          });
        }
      }
      
      updatePromises.push(owner.save());
    }
    
    await Promise.all(updatePromises);
    
    // 7. 활동 로그 기록
    await ActivityLog.logActivity(
      roomId,
      req.user.id,
      `${req.user.firstName} ${req.user.lastName}`,
      'confirm_schedule',
      `자동배정 시간 확정 완료 (${autoAssignedSlots.length}개 슬롯, 조원 ${Object.keys(slotsByUser).length}명 + 방장)`
    );
    
    // 8. 성공 응답
    res.json({
      msg: '배정 시간이 각 조원과 방장의 개인일정으로 확정되었습니다.',
      confirmedSlotsCount: autoAssignedSlots.length,
      affectedMembersCount: Object.keys(slotsByUser).length
    });
    
  } catch (error) {
    console.error('Error confirming schedule:', error);
    res.status(500).json({ msg: `확정 처리 중 오류가 발생했습니다: ${error.message}` });
  }
};

// 헬퍼 함수: day 문자열을 숫자로 변환
const getDayOfWeekNumber = (day) => {
  const dayMap = {
    'monday': 1,
    'tuesday': 2,
    'wednesday': 3,
    'thursday': 4,
    'friday': 5,
    'saturday': 6,
    'sunday': 7
  };
  return dayMap[day] || 1;
};
```

#### 2.2 라우트 추가
**파일**: `server/routes/coordination.js` (또는 해당 라우트 파일)

```javascript
const { confirmSchedule } = require('../controllers/coordinationSchedulingController');

router.post('/rooms/:roomId/confirm-schedule', auth, confirmSchedule);
```

---

### Phase 3: 클라이언트 서비스 함수 추가

#### 3.1 API 호출 함수
**파일**: `client/src/services/coordinationService.js`

```javascript
/**
 * 자동배정된 시간을 각 조원의 개인일정으로 확정
 */
confirmSchedule: async (roomId) => {
  try {
    const token = await auth.currentUser?.getIdToken();
    const response = await fetch(`${API_BASE_URL}/api/coordination/rooms/${roomId}/confirm-schedule`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      }
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.msg || 'Failed to confirm schedule');
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error confirming schedule:', error);
    throw error;
  }
}
```

#### 3.2 핸들러 함수
**파일**: `client/src/components/tabs/CoordinationTab/index.js`

```javascript
const handleConfirmSchedule = async () => {
  if (!currentRoom?._id) return;
  
  // 자동배정된 슬롯 확인
  const autoAssignedSlots = currentRoom.timeSlots?.filter(slot => 
    slot.assignedBy && slot.status === 'confirmed'
  ) || [];
  
  if (autoAssignedSlots.length === 0) {
    showAlert('확정할 자동배정 시간이 없습니다.');
    return;
  }
  
  if (!window.confirm(
    `자동배정된 ${autoAssignedSlots.length}개의 시간을 각 조원의 개인일정으로 확정하시겠습니까?\n\n` +
    `확정된 시간은 조원들의 프로필 탭 > 개인시간에 추가되며, 이후 자동배정에서 제외됩니다.`
  )) {
    return;
  }
  
  try {
    const result = await coordinationService.confirmSchedule(currentRoom._id);
    
    showAlert(
      `${result.confirmedSlotsCount}개의 시간이 ${result.affectedMembersCount}명의 조원 개인일정으로 확정되었습니다.`,
      'success'
    );
    
    // 방 정보 새로고침 (필요시)
    await fetchRoomDetails(currentRoom._id);
    
  } catch (error) {
    showAlert(`확정 처리 실패: ${error.message}`, 'error');
  }
};
```

#### 3.3 props 연결
**파일**: `client/src/components/tabs/CoordinationTab/index.js`

```jsx
<AutoSchedulerPanel
  // ... 기존 props
  onConfirmSchedule={handleConfirmSchedule}
  currentRoom={currentRoom}
/>
```

---

### Phase 4: UI 개선 및 추가 기능

#### 4.1 확정된 시간 시각적 구분
**파일**: `client/src/components/timetable/TimetableGrid.js`

- 확정된 시간을 다른 색상으로 표시
- 예: 파란색(자동배정) → 초록색(확정됨)

#### 4.2 조원 목록에서 개인일정 표시
**파일**: `client/src/components/coordination/MemberList.js`

- 조원의 시간표 모달에서 확정된 시간을 개인일정으로 표시
- "개인일정" 뱃지 추가

#### 4.3 확정 취소 기능 (옵션)
**기능**: 확정된 시간을 다시 되돌리기

**구현 방안**:
1. `personalTimes`에 확정 시간 저장 시 메타데이터 추가
   ```javascript
   {
     // ...
     metadata: {
       confirmedFromRoom: roomId,
       confirmedAt: Date
     }
   }
   ```
2. 취소 API 엔드포인트 추가
   - `POST /api/coordination/rooms/:roomId/unconfirm-schedule`
   - 해당 방에서 확정된 시간만 제거

#### 4.4 초기화 버튼 동작 개선
**파일**: `client/src/components/scheduler/AutoSchedulerPanel.js`

**현재**: "전체 비우기" 버튼은 모든 timeSlots 삭제

**개선**: 
- 확정된 시간은 삭제하지 않고 유지
- 또는 확인 메시지에 "확정된 시간도 삭제됩니다" 경고 추가

---

## 📊 데이터 흐름

```
┌─────────────────────────────────────────────────────┐
│  1. 방장: 자동배정 실행                              │
│     → Room.timeSlots에 배정 결과 저장                │
│       (assignedBy: 방장ID, status: 'confirmed')     │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│  2. 방장: 확정 버튼 클릭                             │
│     → POST /api/coordination/rooms/:id/confirm      │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│  3. 서버: 각 조원의 User 모델 업데이트               │
│     → personalTimes 배열에 확정 시간 추가            │
│       - title: "방이름 확정 시간"                   │
│       - type: 'event'                                │
│       - isRecurring: false                           │
│       - specificDate: "2025-05-15"                   │
│       - color: '#10B981' (초록색)                    │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│  4. 서버: 방장의 User 모델 업데이트 ★ 중요!         │
│     → personalTimes 배열에 각 조원별 수업 시간 추가  │
│       - title: "방이름 수업 (조원이름)"             │
│       - type: 'event'                                │
│       - isRecurring: false                           │
│       - specificDate: "2025-05-15"                   │
│       - color: '#3B82F6' (파란색)                    │
│     ※ 같은 시간대에 여러 조원이 있으면 개별로 추가   │
│       예: 9-11시에 A,B,C → 3개의 개인일정 생성      │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│  5. 효과                                             │
│     - 조원: 프로필 탭 > 개인시간에 "확정 시간" 표시  │
│     - 방장: 프로필 탭 > 개인시간에 "수업" 표시       │
│     - 조원 목록 > 시간표 모달에서 개인일정으로 표시  │
│     - 이후 자동배정 시 해당 시간 제외됨              │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│  2. 방장: 확정 버튼 클릭                             │
│     → POST /api/coordination/rooms/:id/confirm      │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│  3. 서버: 각 조원의 User 모델 업데이트               │
│     → personalTimes 배열에 확정 시간 추가            │
│       - title: "방이름 확정 시간"                   │
│       - type: 'event'                                │
│       - isRecurring: false                           │
│       - specificDate: "2025-05-15"                   │
│       - color: '#10B981' (초록색)                    │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│  4. 효과                                             │
│     - 프로필 탭 > 개인시간 섹션에 표시됨             │
│     - 조원 목록 > 시간표 모달에서 개인일정으로 표시  │
│     - 이후 자동배정 시 해당 시간 제외됨              │
└─────────────────────────────────────────────────────┘
```

---

## ✅ 체크리스트

### 백엔드
- [ ] `confirmSchedule` 함수 구현 (`coordinationSchedulingController.js`)
- [ ] `getDayOfWeekNumber` 헬퍼 함수 추가
- [ ] 라우트 등록 (`POST /api/coordination/rooms/:roomId/confirm-schedule`)
- [ ] 활동 로그 기록
- [ ] 에러 처리 및 검증
  - [ ] 방장 권한 확인
  - [ ] 자동배정 슬롯 존재 여부 확인
  - [ ] 중복 방지

### 프론트엔드
- [ ] `AutoSchedulerPanel`에 확정 버튼 추가
- [ ] `handleConfirmSchedule` 핸들러 추가
- [ ] `coordinationService.confirmSchedule` API 함수 추가
- [ ] 확정 상태 UI 표시
- [ ] 확인 대화상자 추가
- [ ] 성공/실패 알림 처리

### UI/UX 개선
- [ ] 확정된 시간 시각적 구분 (색상 변경)
- [ ] 조원 목록에서 개인일정 표시
- [ ] 로딩 상태 표시
- [ ] 에러 메시지 표시

### 테스트
- [ ] 자동배정 → 확정 플로우 테스트
- [ ] 여러 조원에게 동시 적용 테스트
- [ ] 중복 방지 테스트
- [ ] 방장 권한 확인 테스트
- [ ] 프로필 탭에서 확정된 시간 확인

### 문서화
- [ ] API 문서 업데이트
- [ ] 사용자 가이드 작성
- [ ] 코드 주석 추가

---

## 🚀 배포 순서

1. **백엔드 먼저 배포**
   - API 엔드포인트 추가
   - 데이터베이스 마이그레이션 (필요시)

2. **프론트엔드 배포**
   - UI 업데이트
   - API 연동

3. **테스트 환경 검증**
   - 기능 테스트
   - 버그 수정

4. **프로덕션 배포**
   - 점진적 배포 (Canary/Blue-Green)
   - 모니터링

---

## 🔍 추가 고려사항

### 1. 방장 수업 시간 개별 추가
- **상황**: 같은 시간대에 여러 조원이 배정될 수 있음
  - 예: 월요일 9-11시에 A, B, C 세 명 배정
- **처리 방식**: 방장의 개인일정에 각각 개별로 추가
  - "방이름 수업 (A)" - 9-11시
  - "방이름 수업 (B)" - 9-11시  
  - "방이름 수업 (C)" - 9-11시
  - → 총 3개의 개인일정이 같은 시간대에 겹쳐서 표시됨
- **이유**: 각각 다른 사람을 가르치는 것이므로 개별 관리 필요

### 2. 색상 구분
- **조원**: 초록색 (#10B981) - "확정 시간"
- **방장**: 파란색 (#3B82F6) - "수업 시간"
- 시각적으로 구분하여 쉽게 식별 가능

### 3. 성능 최적화
- 대량의 조원/슬롯 처리 시 배치 처리 고려
- 트랜잭션 사용하여 일관성 보장

### 2. 확장 가능성
- 확정 시 알림 전송 (이메일/푸시)
- 확정 이력 관리 (누가 언제 확정했는지)
- 부분 확정 기능 (특정 조원만)

### 3. 보안
- 권한 검증 철저히
- 입력 검증 (SQL Injection, XSS 방지)

### 4. 사용자 경험
- 확정 전 미리보기
- 실행 취소 기능
- 진행 상황 표시

---

## 📝 참고 파일

### 클라이언트
- `client/src/components/tabs/CoordinationTab/index.js` - 메인 탭
- `client/src/components/scheduler/AutoSchedulerPanel.js` - 자동배정 패널
- `client/src/components/tabs/ProfileTab/index.js` - 프로필 탭
- `client/src/services/coordinationService.js` - API 서비스
- `client/src/components/coordination/MemberList.js` - 조원 목록

### 서버
- `server/controllers/coordinationSchedulingController.js` - 자동배정 컨트롤러
- `server/models/user.js` - User 모델
- `server/models/room.js` - Room 모델
- `server/routes/coordination.js` - 라우트

---

## 💡 예상 문제 및 해결

### 문제 1: 시간대 불일치
**증상**: 날짜가 하루 차이나는 문제
**해결**: UTC 기준으로 통일, `toISOString().split('T')[0]` 사용

### 문제 2: 중복 확정
**증상**: 같은 시간이 여러 번 추가됨
**해결**: 중복 체크 로직 추가 (날짜 + 시간 비교)

### 문제 3: 대량 업데이트 성능
**증상**: 조원이 많을 때 느림
**해결**: `Promise.all` 사용, 배치 업데이트

---

## 📅 예상 일정

- **Phase 1 (UI)**: 1일
- **Phase 2 (서버 API)**: 1-2일
- **Phase 3 (클라이언트 연동)**: 1일
- **Phase 4 (UI 개선)**: 1-2일
- **테스트 및 디버깅**: 2일

**총 예상 기간**: 6-8일

---

## ✨ 완료 후 기대 효과

1. **사용자 편의성 향상**
   - 자동배정 결과를 한 번에 개인일정으로 확정
   - 수동으로 하나씩 추가할 필요 없음

2. **데이터 일관성**
   - 확정된 시간은 이후 자동배정에서 자동 제외
   - 중복 배정 방지

3. **워크플로우 개선**
   - 자동배정 → 확정 → 다음 주 배정의 자연스러운 흐름

---

**작성일**: 2025-12-05
**작성자**: AI Assistant (Claude)

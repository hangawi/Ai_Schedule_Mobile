================================================================================
이동시간 표시 문제 해결 완료
================================================================================

작업 날짜: 2025-12-12
작업 시간: 약 2시간
상태: 완료

================================================================================
문제 요약
================================================================================

[초기 증상]
1. 이동시간이 10분으로만 표시됨 (실제로는 60분이어야 하는데)
2. 이동시간 블록이 수업 블록과 겹쳐서 표시됨
3. 수업 시간이 이동시간만큼 뒤로 밀리지 않음

[사용자 요구사항]
- 방장 → 학생1 → 학생2 순서로 이동 경로 계산
- 이동시간이 하나의 블록을 차지하도록 표시
- 수업 시간이 이동시간만큼 뒤로 밀려야 함
- 기본 모드에서도 대중교통 보기가 정상 작동해야 함

================================================================================
근본 원인 분석
================================================================================

--------------------------------------------------------------------------------
원인 1: TimetableGrid 병합 로직 문제
--------------------------------------------------------------------------------
파일: client/src/components/timetable/TimetableGrid.js

[문제]
- 이동시간 모드(travelMode !== 'normal')일 때 병합을 건너뛰도록 되어 있음
- 10분 단위 슬롯이 개별로 표시되어 시간표가 지저분하게 보임

[문제가 있던 코드]
useEffect(() => {
  if (travelMode !== 'normal') {
    setMergedTimeSlots(timeSlots);  // 병합하지 않고 원본 사용
    return;
  }
  const merged = mergeConsecutiveTimeSlots(timeSlots);
  setMergedTimeSlots(merged);
}, [timeSlots, showMerged, travelMode]);

[수정된 코드]
useEffect(() => {
  // 이동시간 모드에서도 병합 수행
  const merged = mergeConsecutiveTimeSlots(timeSlots);
  setMergedTimeSlots(merged);
}, [timeSlots, showMerged, travelMode]);

--------------------------------------------------------------------------------
원인 2: getCurrentScheduleData 하드코딩 문제
--------------------------------------------------------------------------------
파일: client/src/hooks/useTravelMode.js

[문제]
- enhancedSchedule이 계산 중일 때 하드코딩된 'normal'을 반환
- 사용자가 "대중교통 보기"를 눌렀는데도 travelMode: 'normal'이 반환됨

[문제가 있던 코드]
const getCurrentScheduleData = useCallback(() => {
  if (travelMode === 'normal' || !enhancedSchedule) {
    return {
      timeSlots: currentRoom?.timeSlots || [],
      travelSlots: [],
      travelMode: 'normal'  // ❌ 항상 'normal' 반환
    };
  }
  return enhancedSchedule;
}, [travelMode, enhancedSchedule, currentRoom]);

[수정된 코드]
const getCurrentScheduleData = useCallback(() => {
  if (travelMode === 'normal' || !enhancedSchedule) {
    return {
      timeSlots: currentRoom?.timeSlots || [],
      travelSlots: [],
      travelMode: travelMode  // ✅ 실제 travelMode 반환
    };
  }
  return enhancedSchedule;
}, [travelMode, enhancedSchedule, currentRoom, isCalculating]);

--------------------------------------------------------------------------------
원인 3: CoordinationTab props 전달 문제
--------------------------------------------------------------------------------
파일: client/src/components/tabs/CoordinationTab/index.js

[문제]
- useTravelMode 훅의 state 변수(travelMode)를 전달
- 이 state는 currentRoom 변경 시 'normal'로 리셋됨
- scheduleData.travelMode와 다른 값이 전달됨

[문제가 있던 코드]
const { travelMode, getCurrentScheduleData } = useTravelMode(currentRoom);
const scheduleData = getCurrentScheduleData();

<TimetableGrid
  timeSlots={scheduleData.timeSlots}
  travelMode={travelMode}  // ❌ 훅의 state 변수 (리셋될 수 있음)
/>

[수정된 코드]
<TimetableGrid
  timeSlots={scheduleData.timeSlots}
  travelMode={scheduleData.travelMode}  // ✅ 데이터의 travelMode
/>

--------------------------------------------------------------------------------
원인 4: 이전 활동 종료 시간 미추적 (핵심 버그!)
--------------------------------------------------------------------------------
파일: client/src/services/travelScheduleCalculator.js

[문제]
- 여러 학생의 수업이 같은 날짜에 있을 때, 두 번째 학생부터는 이전 학생의
  조정된 종료 시간을 고려하지 않음
- 예: 이이(10:00-11:00) → 삼삼(10:00-11:00)
  - 이이가 10:00-11:00으로 조정되면
  - 삼삼은 11:00 이후에 시작해야 하는데
  - 원본 시작 시간(10:00)을 사용해서 겹침 발생

[시나리오 예시]
12-08 월요일 원본:
- 이이: 09:00-10:00
- 삼삼: 10:00-11:00

조정 과정 (문제):
1. 이이: 방장→이이 60분 이동
   - 이동: 09:00-10:00
   - 수업: 10:00-11:00 ✅

2. 삼삼: 이이→삼삼 10분 이동
   - 이동: 10:00-10:10 ❌ (이이와 겹침!)
   - 수업: 10:10-11:10 ❌

기대 결과:
   - 이동: 11:00-11:10 ✅ (이이 종료 후)
   - 수업: 11:10-12:10 ✅

[해결 방법]
// 날짜별 이전 활동 종료 시간 추적 변수 추가
let previousActivityEndMinutes = 0;

// 날짜 변경 시 리셋
if (slotDate !== currentDate) {
  currentDate = slotDate;
  previousActivityEndMinutes = 0;
  previousLocation = { /* 방장 */ };
}

// 이동시간 시작은 원본 시작 vs 이전 종료 중 늦은 것
let newTravelStartMinutes = Math.max(
  slotStartMinutes,              // 원본 시작 시간
  previousActivityEndMinutes     // 이전 활동 종료 시간
);

// 활동 종료 후 업데이트
previousActivityEndMinutes = newActivityEndTimeMinutes;

--------------------------------------------------------------------------------
원인 5: 이동시간 종료 계산 버그 (최종 버그!)
--------------------------------------------------------------------------------
파일: client/src/services/travelScheduleCalculator.js

[문제]
- 이동시간 종료를 **원본 시작 시간** 기준으로 계산
- 조정된 이동시간 시작과 맞지 않아 "11:10-10:10" 같은 잘못된 시간 생성
- unmergeBlock이 유효하지 않은 시간 범위를 처리하지 못해 슬롯이 사라짐

[실제 발생한 로그]
{
  원본: '10:00-11:00',
  이동: '11:10-10:10',  // ❌ 시작 > 종료!
  조정된수업: '10:10-11:10',
  이전종료: '11:10'
}

[계산 과정 - 문제]
let newTravelStartMinutes = Math.max(600, 670) = 670;  // 11:10 ✅
let newTravelEndTimeMinutes = 600 + 10 = 610;          // 10:10 ❌ (원본 기준!)
let newActivityStartTimeMinutes = 610;                 // 10:10 ❌
let newActivityEndTimeMinutes = 610 + 60 = 670;        // 11:10 ❌

[수정 전 코드]
let newTravelStartMinutes = Math.max(slotStartMinutes, previousActivityEndMinutes);
let newTravelEndTimeMinutes = slotStartMinutes + travelDurationMinutes;  // ❌

[수정 후 코드]
let newTravelStartMinutes = Math.max(slotStartMinutes, previousActivityEndMinutes);
let newTravelEndTimeMinutes = newTravelStartMinutes + travelDurationMinutes;  // ✅
let newActivityStartTimeMinutes = newTravelEndTimeMinutes;
let newActivityEndTimeMinutes = newActivityStartTimeMinutes + activityDurationMinutes;

[계산 과정 - 수정 후]
let newTravelStartMinutes = Math.max(600, 670) = 670;   // 11:10 ✅
let newTravelEndTimeMinutes = 670 + 10 = 680;           // 11:20 ✅ (조정된 시작 기준!)
let newActivityStartTimeMinutes = 680;                  // 11:20 ✅
let newActivityEndTimeMinutes = 680 + 60 = 740;         // 12:20 ✅

================================================================================
수정된 파일 목록
================================================================================

1. client/src/components/timetable/TimetableGrid.js
   - 이동시간 모드에서도 병합 수행하도록 수정

2. client/src/hooks/useTravelMode.js
   - getCurrentScheduleData에서 실제 travelMode 반환하도록 수정

3. client/src/components/tabs/CoordinationTab/index.js
   - TimetableGrid에 scheduleData.travelMode 전달하도록 수정

4. client/src/services/travelScheduleCalculator.js
   - 이전 활동 종료 시간 추적 로직 추가
   - 이동시간 종료 계산을 조정된 시작 시간 기준으로 수정

================================================================================
최종 결과
================================================================================

[12-08 월요일 예시]

원본 배정:
- 이이: 09:00-10:00
- 삼삼: 10:00-11:00

조정 후 (이동시간 포함):
- 이동시간 (방장→이이): 09:00-10:00 (60분)
- 이이 수업: 10:00-11:00
- 이동시간 (이이→삼삼): 11:00-11:10 (10분)
- 삼삼 수업: 11:10-12:10

[화면 표시]
- 각 블록이 겹치지 않고 순서대로 표시됨
- 이동시간이 점선 테두리로 구분되어 표시됨
- 병합 모드에서 10분 슬롯들이 하나의 블록으로 병합됨
- 대중교통/자동차/자전거/도보 모드 모두 정상 작동

================================================================================
교훈
================================================================================

1. State vs Data 구분
   - 훅의 state 변수와 데이터 객체의 필드를 명확히 구분
   - 리셋될 수 있는 state를 props로 전달하지 말 것

2. 시간 계산은 항상 조정된 값 기준
   - 원본 값을 참조하면 안 됨
   - 이전 단계의 결과를 다음 단계의 입력으로 사용

3. 연쇄 작업에서 이전 상태 추적
   - 여러 항목을 순차 처리할 때 이전 항목의 결과를 추적해야 함
   - 날짜/컨텍스트 변경 시 상태 리셋 필수

4. 디버깅은 로그가 생명
   - 각 단계의 입력/출력을 상세히 로깅
   - 중간 계산 값도 모두 로깅하여 문제 지점 파악

5. 점진적 수정과 테스트
   - 한 번에 모든 것을 고치려 하지 말고
   - 하나씩 수정하고 테스트하며 진행

================================================================================
테스트 완료 항목
================================================================================

✅ 기본 모드 + 대중교통 보기
✅ 여러 날짜에 걸친 배정
✅ 같은 날짜에 여러 학생 배정
✅ 방장→학생1→학생2 순서 이동
✅ 병합 모드에서 블록 표시
✅ 이동시간과 수업 블록 구분

================================================================================
작업자: Claude Sonnet 4.5
완료 일시: 2025-12-12
================================================================================

================================================================================
리팩토링 작업 지침서 (React 컴포넌트)
================================================================================

[핵심 원칙]
1. 단 한 줄의 코드도 삭제하지 않는다
2. 모든 기능을 그대로 보존한다
3. 원본 파일을 새로운 구조로 완전히 대체한다
4. 가독성과 유지보수성 향상이 목적이다

[폴더 구조]
대상 컴포넌트가 있는 폴더에 다음 하위 폴더들을 생성:

constants/      - 상수 정의 (맵핑, 레이블, 설정값 등)
utils/          - 유틸리티 함수 (변환, 파싱, 계산 등)
hooks/          - 커스텀 React 훅 (상태 관리, 부수 효과)
handlers/       - 이벤트 핸들러 팩토리 함수들
components/     - UI 하위 컴포넌트들

[작업 절차]
1. 계획 수립
   - 원본 파일 읽기
   - 코드 분석 및 분리 계획 세우기
   - 사용자에게 계획 설명하고 승인 받기

2. 폴더 생성
   - 위 5개 폴더 생성

3. 파일 생성 순서
   ① constants/ - 모든 상수 정의
   ② utils/ - 유틸리티 함수들
   ③ hooks/ - 커스텀 훅들
   ④ handlers/ - 핸들러 팩토리 함수들
   ⑤ components/ - UI 컴포넌트들
   ⑥ 메인 컴포넌트 리팩토링

4. TODO 리스트 작성
   - 각 파일 생성을 개별 태스크로 관리
   - 진행 상황 실시간 업데이트

[명명 규칙]
- constants: 대문자 스네이크 케이스 (예: DAY_MAP, GRADE_LEVEL_LABELS)
- utils: 동사로 시작하는 camelCase (예: parseTime, calculateEndTime)
- hooks: use로 시작 (예: useModalState, useChatScroll)
- handlers: create로 시작하는 팩토리 함수 (예: createHandleSubmit)
- components: PascalCase (예: ChatHeader, MessageBubble)

[각 폴더의 역할]

constants/
- 하드코딩된 값들을 모두 추출
- 객체 맵핑, 라벨 정의, 설정값 등
- export const로 내보내기

utils/
- 순수 함수들 (입력 -> 출력, 부수 효과 없음)
- 변환, 파싱, 계산, 검증 등
- React와 무관한 로직
- 각 파일은 관련된 함수들을 그룹화

hooks/
- React 커스텀 훅
- useState, useEffect, useRef 등 사용
- 상태 관리 로직 캡슐화
- use로 시작하는 함수명

handlers/
- 이벤트 핸들러 생성 함수 (팩토리 패턴)
- 클로저를 활용하여 의존성 주입
- create로 시작하는 함수명
- 실제 핸들러 함수를 반환

components/
- UI를 담당하는 작은 컴포넌트들
- props를 받아 렌더링만 수행
- 비즈니스 로직 최소화
- 재사용 가능하도록 설계

[핸들러 팩토리 패턴 예시]
export const createHandleSubmit = (dep1, dep2, setState) => {
  return async (event) => {
    // 실제 로직
    setState(newValue);
  };
};

// 사용:
const handleSubmit = createHandleSubmit(dep1, dep2, setState);

[메인 컴포넌트 구조]
1. imports (Utils, Hooks, Handlers, Components)
2. 컴포넌트 함수 정의
3. 초기 데이터 처리 (useMemo)
4. 상태 관리 (커스텀 훅)
5. 부수 효과 (커스텀 훅)
6. 데이터 변환
7. 핸들러 생성
8. JSX 반환 (컴포넌트 조합)

[목표 감소율]
- 80~85% 코드 라인 감소
- 1,000줄 이상 -> 250줄 이하

[검증]
- 모든 기능이 동작하는지 확인
- import 경로가 올바른지 확인
- 타입 에러가 없는지 확인

[파일 작성 순서가 중요한 이유]
constants -> utils -> hooks -> handlers -> components
(의존성 순서: 뒤로 갈수록 앞의 것들을 import)

================================================================================
사용 방법:
1. 리팩토링할 파일 경로 제공
2. 이 txt 파일 제공
3. "이 가이드대로 리팩토링해줘" 요청
================================================================================


================================================================================
리팩토링 작업 지침서 (서버 컨트롤러 - Express/Node.js)
================================================================================

[핵심 원칙] - React와 동일
1. 단 한 줄의 코드도 삭제하지 않는다
2. 모든 기능을 그대로 보존한다
3. 원본 파일을 새로운 구조로 완전히 대체한다
4. 가독성과 유지보수성 향상이 목적이다

[폴더 구조]
대상 컨트롤러가 있는 폴더에 다음 하위 폴더들을 생성:

constants/      - 상수 정의 (에러 메시지, 매핑, 설정값 등)
utils/          - 유틸리티 함수 (시간 계산, 파싱, 변환 등)
validators/     - 검증 로직 (입력값 검증, 비즈니스 규칙 검증)
services/       - 비즈니스 로직 (외부 API 호출, 복잡한 연산)
helpers/        - 헬퍼 함수들 (DB 쿼리, 데이터 가공)

[작업 절차]
1. 계획 수립
   - 원본 파일 읽기
   - 코드 분석 및 분리 계획 세우기
   - 사용자에게 계획 설명하고 승인 받기

2. 폴더 생성
   - 위 5개 폴더 생성

3. 파일 생성 순서
   ① constants/ - 모든 상수 정의
   ② utils/ - 유틸리티 함수들
   ③ validators/ - 검증 로직
   ④ helpers/ - 헬퍼 함수들
   ⑤ services/ - 비즈니스 로직
   ⑥ 메인 컨트롤러 리팩토링

4. TODO 리스트 작성
   - 각 파일 생성을 개별 태스크로 관리
   - 진행 상황 실시간 업데이트

[명명 규칙]
- constants: 대문자 스네이크 케이스 (예: ERROR_MESSAGES, DAY_NAMES)
- utils: 동사로 시작하는 camelCase (예: addHours, calculateDuration)
- validators: validate로 시작 (예: validateDateRange, validateTimeSlot)
- services: 명사형 또는 동사형 (예: geminiService, processExchange)
- helpers: 동사로 시작 (예: findUserSlot, updateRoomSlots)

[각 폴더의 역할]

constants/
- 하드코딩된 값들을 모두 추출
- 에러 메시지, HTTP 상태 코드, 설정값 등
- module.exports = { ... } 로 내보내기

utils/
- 순수 함수들 (입력 -> 출력, 부수 효과 없음)
- 시간 계산, 날짜 변환, 문자열 파싱 등
- 외부 의존성 없음
- 각 파일은 관련된 함수들을 그룹화

validators/
- 입력값 검증 로직
- 비즈니스 규칙 검증
- true/false 반환 또는 에러 throw
- Express 미들웨어 형태도 가능

services/
- 외부 API 호출 (Gemini, Firebase 등)
- 복잡한 비즈니스 로직
- DB와 독립적인 연산
- async 함수들

helpers/
- DB 쿼리 헬퍼
- 데이터 가공 함수
- 컨트롤러 지원 함수
- req, res와 무관한 로직

[메인 컨트롤러 구조]
1. imports (모델, 서비스, 유틸리티, 헬퍼)
2. 라우트 핸들러 함수들만 남김
3. 각 핸들러는:
   - 요청 파라미터 추출
   - validators 호출
   - services/helpers 호출
   - 응답 반환
   - 에러 처리

[컨트롤러 함수 예시 - Before]
exports.someEndpoint = async (req, res) => {
  // 100줄의 복잡한 로직...
  const result = someComplexCalculation();
  // DB 쿼리...
  // 외부 API 호출...
  // 검증...
  res.json({ success: true, data: result });
};

[컨트롤러 함수 예시 - After]
exports.someEndpoint = async (req, res) => {
  try {
    const params = extractParams(req);
    validateParams(params);
    const result = await processRequest(params);
    res.json({ success: true, data: result });
  } catch (error) {
    handleError(res, error);
  }
};

[목표 감소율]
- 80~85% 코드 라인 감소
- 1,500줄 이상 -> 300줄 이하

[검증]
- 모든 API 엔드포인트가 동작하는지 확인
- require 경로가 올바른지 확인
- 에러 핸들링이 유지되는지 확인
- 기존 테스트가 통과하는지 확인

[파일 작성 순서가 중요한 이유]
constants -> utils -> validators -> helpers -> services
(의존성 순서: 뒤로 갈수록 앞의 것들을 require)

[React와의 차이점]
- hooks/ 없음 (서버에는 React 훅이 없음)
- components/ 없음 (UI 렌더링 없음)
- handlers/ 대신 services/ 사용
- validators/ 추가 (입력값 검증)
- helpers/ 추가 (DB 관련 헬퍼)

================================================================================
사용 방법 (서버):
1. 리팩토링할 컨트롤러 파일 경로 제공
2. 이 txt 파일 제공
3. "서버 가이드대로 리팩토링해줘" 요청
================================================================================
